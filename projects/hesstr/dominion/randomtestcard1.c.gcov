        -:    0:Source:randomtestcard1.c
        -:    0:Graph:randomtestcard1.gcno
        -:    0:Data:randomtestcard1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include <string.h>
        -:    4:#include <stdio.h>
        -:    5:#include "rngs.h"
        -:    6:
        -:    7:#define MAX_HAND_COUNT 10
        -:    8:
     1001:    9:int printError(struct gameState *pre, struct gameState *post, int coinsGained, int discarded, int cardsGained, int buysGained, int player, int testNum)
        -:   10:{
     1001:   11:    if((pre->numBuys + buysGained) != post->numBuys || post->handCount[player] != pre->handCount[player] - discarded + cardsGained || (pre->coins + coinsGained) != post->coins)
        -:   12:    {
        -:   13:        //print out player state, expected and actual as well as test number
      979:   14:        printf("\nTest Number: %d\n", testNum);
        -:   15:
      979:   16:        printf("\tNumber of Buys:\n");
      979:   17:        printf("\t\tExpected: %d, Actual: %d\n", pre->numBuys + buysGained, post->numBuys);
        -:   18:
      979:   19:        printf("\tNumber coins:\n");
      979:   20:        printf("\t\tExpected = %d, Actual = %d\n", pre->coins + coinsGained, post->coins);
        -:   21:
      979:   22:        printf("\tHand count:\n");
      979:   23:        printf("\t\tExpected = %d, Actual = %d\n", pre->handCount[player] - discarded + cardsGained, post->handCount[player]);
        -:   24:    }
        -:   25:
     1001:   26:    return 0;
        -:   27:}
        -:   28:
        1:   29:int main()
        -:   30:{
        1:   31:    int cardsGained = 0;
        1:   32:    int discarded = 0;
        1:   33:    int coinsGained = 0;
        1:   34:    int buysGained = 0;
        -:   35:
        1:   36:    int choice1 = 0;
        1:   37:    int seed = 1000;
        1:   38:    int numPlayers = 2;
        1:   39:    int player1 = 0;
        -:   40:	struct gameState preG, postG;
        1:   41:	int k[10] = {adventurer, embargo, village, minion, mine, cutpurse,
        -:   42:			sea_hag, baron, smithy, council_room};
        -:   43:
        1:   44:    printf("\n\n-------------Randomly Testing Baron---------\n\n");
        1:   45:    initializeGame(numPlayers, k, seed, &preG);
        -:   46:
        1:   47:    srand(time(NULL));
        -:   48:
        1:   49:    int count = 0;
        -:   50:
     1003:   51:    while(count <= 1000)
        -:   52:    {
     1001:   53:        coinsGained = 0;
     1001:   54:        buysGained = 0;
     1001:   55:        discarded = 0;
     1001:   56:        cardsGained = 0;
        -:   57:
     1001:   58:        choice1 = rand() % 2; //choose to either get rid of an estate or not
        -:   59:
     6006:   60:        for(int i = 0; i < preG.handCount[player1]; i++) //use non-randomized player hand size to randomize the players hand
        -:   61:        {
     5005:   62:            preG.hand[player1][i] = rand() % 27; //0 to 26
        -:   63:        }
        -:   64:
        -:   65:        //randomize supply count for estates
     1001:   66:        preG.supplyCount[estate] = rand() % 12 + (-5); //generate random numbers between -5 and 6
        -:   67:
     1001:   68:        buysGained = 1;
     1001:   69:        if(choice1 == 1)
        -:   70:        {
      481:   71:            coinsGained = 4;
      481:   72:            discarded = 1;
        -:   73:        }
        -:   74:        else
        -:   75:        {
      520:   76:            cardsGained = 1;
        -:   77:        }
        -:   78:        
     1001:   79:        memcpy(&postG, &preG, sizeof(struct gameState));
        -:   80:
     1001:   81:        baronLogic(choice1, &postG, player1);
        -:   82:
     1001:   83:        printError(&preG, &postG, coinsGained, discarded, cardsGained, buysGained, player1, count);
        -:   84:
     1001:   85:        count++;
        -:   86:    }
        -:   87:
        1:   88:    return 0;
        -:   89:}
        -:   90:
        -:   91://how do we want to catch errors in a random tester?
