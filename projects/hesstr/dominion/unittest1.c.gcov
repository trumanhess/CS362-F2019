        -:    0:Source:unittest1.c
        -:    0:Graph:unittest1.gcno
        -:    0:Data:unittest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://NEED TO ZERO OUT GAME STRUCTS AFTER USING THEM!!
        -:    2:#include "dominion.h"
        -:    3:#include "dominion_helpers.h"
        -:    4:#include <string.h>
        -:    5:#include <stdio.h>
        -:    6:#include "rngs.h"
        -:    7:#include "custom_assert.h"
        -:    8:
        -:    9:/*
        -:   10:    test 1: get rid of estate and have one in hand
        -:   11:    test 2: get rid of estate, but not have one in hand
        -:   12:    test 3: gain an estate
        -:   13:    test 4: try to gain an estate, but no estates in supply
        -:   14:    test 5: try to gain an estate, but negative amount of estates in supply
        -:   15:*/
        -:   16:
        1:   17:int main()
        -:   18:{
        1:   19:    int cardsGained = 0;
        1:   20:    int discarded = 0;
        1:   21:    int coinsGained = 0;
        1:   22:    int shuffledCards = 0;
        -:   23:
        1:   24:    int handpos = 0, choice1 = 0, choice2 = 0, choice3 = 0, bonus = 0;
        1:   25:    int seed = 1000;
        1:   26:    int numPlayers = 2;
        1:   27:    int thisPlayer = 0;
        -:   28:	struct gameState preG, postG;
        1:   29:	int k[10] = {adventurer, embargo, village, minion, mine, cutpurse,
        -:   30:			sea_hag, baron, smithy, council_room};
        -:   31:
        1:   32:    printf("\n\n-------------Testing Baron---------\n\n");
        -:   33:
        -:   34://REPLACE ALL ASSERTS WITH OWN IMPLEMENTATION
        -:   35:/* 
        -:   36:    test 1: get rid of estate and have one in hand
        -:   37:    expect: to get rid of estate and gain +4 coins 
        -:   38:*/
        1:   39:    printf("Test 1:\n");
        -:   40:    //could make this test more robust by testing multiple estates
        -:   41:    //or estates in different positions in the hand
        -:   42:
        1:   43:    initializeGame(numPlayers, k, seed, &postG);
        -:   44:
        -:   45:    //set players hand
        1:   46:    postG.hand[thisPlayer][0] = steward;
        1:   47:	postG.hand[thisPlayer][1] = copper;
        1:   48:	postG.hand[thisPlayer][2] = duchy;
        1:   49:	postG.hand[thisPlayer][3] = estate;
        1:   50:	postG.hand[thisPlayer][4] = feast;
        1:   51:    postG.coins = 0;
        -:   52:
        1:   53:    memcpy(&preG, &postG, sizeof(struct gameState));
        1:   54:	choice1 = 1;
        1:   55:    discarded = 1;
        1:   56:	cardEffect(baron, choice1, choice2, choice3, &postG, handpos, &bonus);
        -:   57:
        -:   58:    //compare how many buys
        1:   59:    ASSERT((preG.numBuys + 1) == postG.numBuys);
        1:   60:    printf("expected = %d, actual = %d\n", preG.numBuys + 1, postG.numBuys);
        -:   61:    //compare old coins to new coins
        1:   62:    ASSERT((preG.coins + 4) == postG.coins);
        1:   63:    printf("expected = %d, actual = %d\n", preG.coins + 4, postG.coins);
        -:   64:    //compare that card is no longer in hand in both
        -:   65:    //should remove number 3 in hand
        5:   66:    for(int i = 1; i < postG.handCount[thisPlayer]; i++)
        -:   67:    {
        -:   68:        //assert(postG.hand[thisPlayer][i] != estate); //in this case we can just write estate because there is only one estate in our hand
        -:   69:                                                     //might need to change this in the future
        4:   70:        ASSERT(postG.hand[thisPlayer][i] != estate);
        4:   71:        if(postG.hand[thisPlayer][i] == estate)
        -:   72:        {
        1:   73:            printf("estate found in hand at %d\n", i);
        -:   74:        }
        -:   75:    }
        1:   76:    ASSERT(postG.handCount[thisPlayer] == preG.handCount[thisPlayer] - 1);
        1:   77:    printf("Hand count: expected = %d, actual = %d\n", preG.handCount[thisPlayer] - 1, postG.handCount[thisPlayer]);
        -:   78:    //check to see if other stuff is unaffected, like other players and piles
        -:   79:
        -:   80:/* 
        -:   81:    test 2: get rid of estate, but not have one in hand
        -:   82:    expect: gain an estate
        -:   83:*/
        1:   84:    printf("Test 2:\n");
        -:   85:
        -:   86:    //set player hand with no estate
        1:   87:    postG.hand[thisPlayer][0] = steward;
        1:   88:	postG.hand[thisPlayer][1] = copper;
        1:   89:	postG.hand[thisPlayer][2] = duchy;
        1:   90:	postG.hand[thisPlayer][3] = feast;
        -:   91:
        1:   92:    memcpy(&preG, &postG, sizeof(struct gameState));
        1:   93:	choice1 = 1;
        1:   94:    cardsGained = 1;
        1:   95:	cardEffect(baron, choice1, choice2, choice3, &postG, handpos, &bonus);
        -:   96:
        -:   97:    //compare how many buys
        1:   98:    printf("Numer of Buys:\n");
        1:   99:    ASSERT((preG.numBuys + 1) == postG.numBuys);
        1:  100:    printf("\texpected: %d, actual: %d\n", (preG.numBuys + 1), postG.numBuys);
        -:  101:    //compare old coins to new coins
        1:  102:    printf("Number of Coins:\n");
        1:  103:    ASSERT(preG.coins == postG.coins);
        1:  104:    printf("\texpected: %d, actual: %d\n", preG.coins, postG.coins);
        -:  105:
        -:  106:    //the player should gain an estate at the highest hand pos
        1:  107:    ASSERT(postG.hand[thisPlayer][preG.handCount[thisPlayer + 1]] == estate);
        -:  108:
        -:  109:    //assert(postG.handCount[thisPlayer] == preG.handCount[thisPlayer]);
        1:  110:    printf("Hand count:\n");
        1:  111:    ASSERT(postG.handCount[thisPlayer] == preG.handCount[thisPlayer] + 1);
        1:  112:    printf("Hand count: expected = %d, actual = %d\n", preG.handCount[thisPlayer] + 1, postG.handCount[thisPlayer]);
        -:  113:    //check that discard pile is unaffected?
        -:  114:    //amongest other things
        -:  115:
        -:  116:/* 
        -:  117:    test 3:
        -:  118:    to what happens when player chooses to gain an estate 
        -:  119:*/
        -:  120:
        -:  121:    //set players hand
        1:  122:    postG.hand[thisPlayer][0] = steward;
        1:  123:	postG.hand[thisPlayer][1] = copper;
        1:  124:	postG.hand[thisPlayer][2] = duchy;
        1:  125:	postG.hand[thisPlayer][3] = estate;
        1:  126:	postG.hand[thisPlayer][4] = feast;
        -:  127:
        1:  128:    memcpy(&preG, &postG, sizeof(struct gameState));
        1:  129:	choice1 = 0;
        1:  130:	cardEffect(baron, choice1, choice2, choice3, &postG, handpos, &bonus);
        -:  131:
        -:  132:    //compare how many buys
        -:  133:    //assert((preG.numBuys + 1) == postG.numBuys);
        -:  134:    //compare old coins to new coins
        -:  135:    //assert(preG.coins == postG.coins);
        -:  136:
        1:  137:    int numEstates = 0;
        -:  138:    
        5:  139:    for(int i = 0; i < postG.handCount[thisPlayer]; i++)
        -:  140:    {
        -:  141:        //assert(postG.hand[thisPlayer][i] != estate); //in this case we can just write estate because there is only one estate in our hand
        4:  142:        if(postG.hand[thisPlayer][i] == estate)
        -:  143:        {
        1:  144:            numEstates += 1;
        -:  145:        }
        -:  146:    }
        -:  147:    if(numEstates == 2)
        -:  148:    {
        -:  149:        //yeet
        -:  150:    }
        -:  151:    //assert(postG.handCount[thisPlayer] == preG.handCount[thisPlayer] + 1);
        -:  152:
        -:  153:/*
        -:  154:    test 4:
        -:  155:*/
        -:  156:
        -:  157:/*
        -:  158:    test 5:
        -:  159:    expected: to not gain an estate card, everything stays the same, except you get +1 buys
        -:  160:*/
        1:  161:    postG.hand[thisPlayer][0] = steward;
        1:  162:	postG.hand[thisPlayer][1] = copper;
        1:  163:	postG.hand[thisPlayer][2] = duchy;
        1:  164:	postG.hand[thisPlayer][3] = estate;
        1:  165:	postG.hand[thisPlayer][4] = feast;
        1:  166:    postG.coins = 0;
        -:  167:
        1:  168:    memcpy(&preG, &postG, sizeof(struct gameState));
        1:  169:	choice1 = 0;
        1:  170:    postG.supplyCount[estate] = -1;
        1:  171:	cardEffect(baron, choice1, choice2, choice3, &postG, handpos, &bonus);
        -:  172:
        -:  173:    //compare how many buys
        1:  174:    ASSERT((preG.numBuys + 1) == postG.numBuys);
        1:  175:    printf("expected = %d, actual = %d\n", preG.numBuys + 1, postG.numBuys);
        -:  176:    //compare old coins to new coins
        1:  177:    ASSERT(preG.coins == postG.coins);
        1:  178:    printf("expected = %d, actual = %d\n", preG.coins, postG.coins);
        -:  179:    
        1:  180:    ASSERT(postG.handCount[thisPlayer] == preG.handCount[thisPlayer]);
        1:  181:    printf("Hand count: expected = %d, actual = %d\n", preG.handCount[thisPlayer], postG.handCount[thisPlayer]);
        -:  182:    //check to see if other stuff is unaffected, like other players and piles
        -:  183:
        1:  184:    printf("\n\n-------------End Testing Baron---------------\n\n");
        -:  185:
        1:  186:    return 0;
        -:  187:}
